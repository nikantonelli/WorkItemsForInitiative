<!DOCTYPE html>
<html>
<head>
    <title>WorkItemsForInitiative</title>

    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                Ext.define('Rally.ui.tree.PortfolioItemTreeItem', {
        override: 'Rally.ui.tree.PortfolioItemTreeItem',
        alias: 'widget.rallyportfolioitemtreeitem',

        require: [
            'Rally.ui.renderer.RendererFactory'
        ],

        config: {
            displayedFields: ['Name', 'c_ProgressUpdate']
        },

        getContentTpl: function(){
            var me = this;

            return Ext.create('Ext.XTemplate',
                    '<tpl if="this.canDrag()"><div class="icon drag"></div></tpl>',
                    '<tpl if="this._renderPlanOnLowestLevelPortfolioItem()">',
                        '<div class="textContent ellipses" style="width: 40%;">{[this.getFormattedId()]} - {Name}</div><div class="textContent ellipses">{[this.getPlanData()]}</div>',
                    '<tpl else>',
                        '<div class="textContent ellipses">{[this.getFormattedId()]} - {Name}</div>',
                    '</tpl>',
                    '<div class="rightSide">',
                        '{[this.getPercentDone(values)]}',
                    '</div>',
                    {
                        canDrag: function(){
                            return me.getCanDrag();
                        },
                        getActionsGear: function(){
                            return me._buildActionsGearHtml();
                        },
                        getPercentDone: function(){
                            return Rally.ui.renderer.RendererFactory.renderRecordField(me.getRecord(), 'PercentDoneByStoryCount');
                        },
                        getFormattedId: function(){
                            return Rally.ui.renderer.RendererFactory.renderRecordField(me.getRecord(), 'FormattedID');
                        },
                        getPlanData: function() {
                            var plan = me.getRecord().get('c_ProgressUpdate');
//                            var planName = plan && plan.name ? plan.name : "";
                            return plan;
                        },
                        _renderPlanOnLowestLevelPortfolioItem: function() {
                            return true;
                        }
                    }
            );
        },

//        handleReloadAndDraw: function(record) {
//            if(record.self.isLowestLevelPortfolioItem()) {
//                record.data.Plan = this.getRecord().get('Plan');
//            }
//            this.callParent(arguments);
//        }
});


Ext.define('Rally.app.WorkItemsForInitiative.app', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    settingsScope: 'app',
    stateful: true,
    items:[
        { xtype: 'container',
            id: 'headerBox',
            layout: 'column',
            border: 5,
            style: {
                borderColor: Rally.util.Colors.cyan,
                borderStyle: 'solid'
            }
        },
        {
            xtype: 'container',
            id: 'piTreeBox',
            border: 0,
            style: {
                borderColor: Rally.util.Colors.cyan,
                borderStyle: 'solid'
            }
        },
        {
            xtype: 'container',
            id: 'piStatusBox',
            border: 0,
            layout: 'column',
            style: {
                borderColor: Rally.util.Colors.cyan,
                borderStyle: 'solid'
            },
            items: [ {
                    xtype: 'container',
                    id: 'piDefectStatusBox',
                    width: 200,
                    height: 200,
                    hidden: true
                },
                {
                    xtype: 'container',
                    id: 'piTaskStatusBox',
                    hidden: true
                }
            ]
        },
        {
            xtype: 'container',
            layout: 'hbox',
            height: 500,
            items: [
                {
                    xtype: 'container',
                    id: 'piBurnupBox',
                    border: 0,
                    width: '50%',
                    margin: 20,
                    style: {
                        borderColor: Rally.util.Colors.cyan,
                        borderStyle: 'solid'
                    }
                },
                {
                    xtype: 'container',
                    id: 'piBurndownBox',
                    width: '50%',
                    margin: 20,
                    border: 0,
                    style: {
                        borderColor: Rally.util.Colors.cyan,
                        borderStyle: 'solid'
                    }
                }
            ]
        },
        {
            xtype: 'container',
            id: 'piTestCaseBox',
            border: 0,
            style: {
                borderColor: Rally.util.Colors.cyan,
                borderStyle: 'solid'
            }
        },
        {
            xtype: 'container',
            id: 'piTaskBox',
            border: 0,
            style: {
                borderColor: Rally.util.Colors.cyan,
                borderStyle: 'solid'
            }
        },
        {
            xtype: 'container',
            id: 'piDefectBox',
            border: 0,
            style: {
                borderColor: Rally.util.Colors.cyan,
                borderStyle: 'solid'
            }
        },
        {
            xtype: 'container',
            id: 'piStoryBox',
            border: 0,
            style: {
                borderColor: Rally.util.Colors.cyan,
                borderStyle: 'solid'
            }
        }
    ],

    itmStr: "",
    objStr: [],

    appConfig: {
        useLowestPiDates: true,
        autoSelectAll: true,
        ignoreType: false
    },

    portfolioIds: null,
    workItems: null,
    chsrDlg: null,
    lowestPiName: "",

    getState: function() {
        return {
            itmStr: this.itmStr,
            objStr: this.objStr,
            appConfig: this.appConfig
        };
    },

    applyState: function(state) {
        this.itmStr = state.itmStr;
        this.objStr = state.objStr;
        this.appConfig = state.appConfig;
    },


    _findAllLowestLevelPIs: function(app) {

        //Find the lowest level PI type from the store
        if (app.typeStore){
            _.each(app.typeStore.data.items, function(item) {
                if (item.get('Ordinal') === 0){
                    app.lowestPiName = item.get('TypePath');
                }
            });
        }
        else
        {
            Rally.ui.notify.Notifier.show({message: 'Portfolio Type Hierarchy not available. Try and reload page'});
        }

        //In the beginning, we have all the items in itmStr of type Ext.getCmp('typeSelector').rawValue

        var piType = Ext.getCmp('typeSelector').rawValue;

        //Use the lookback API as it allows us to use the '$in' operator and gets
        var piStore = Ext.create('Rally.data.lookback.SnapshotStore', {
            autoLoad: true,
            storeId: 'piStore',
            fetch: ['FormattedID', 'Name', 'Children','ScheduleState', 'PlanEstimate', 'PlannedStartDate','PlannedEndDate'],
            hydrate: ['FormattedID', 'Name', 'ScheduleState','PlannedStartDate','PlannedEndDate' ],
            filters:  [ {
                            property: '_ItemHierarchy',
                            operator: '$in',
                            value: app.objStr
                        },
                        {
                            property: '_TypeHierarchy',
                            value: app.lowestPiName
                        },
                        {
                            property: "__At",
                            value: "current"    //Get only the latest version
                        }
            ],
            listeners: {
                load: function(store, data, success) {

                    //Add all the items that are lowest level PIs to the collection

                    app.portfolioIds = data;

                    //Update all the containers with the details in.
                    app._updateDetailsPanes(app);
                }
            }
        });

    },


    //Choose an artifact (of a particular type) and from the artifact(s) chosen,
    //find the set of lowest level PI item types that comprise this item

    _doArtifactChooserDialog: function(app) {


        //Keep the chooserdialog object in the global space so that we can read the fetched fields in its
        //data records for all the details panes.

        //But when we re-create, we can drop the current one
        if (app.chsrDlg){
            app.chsrDlg.destroy();
        }

        artifactType = 'PortfolioItem';
        title = "Choose ";

        if ( Ext.getCmp('ignoreType').value === false)
        {
            artifactType += '/' + Ext.getCmp('typeSelector').rawValue;
            title += Ext.getCmp('typeSelector').rawValue;
        }

        app.chsrDlg = Ext.create('Rally.ui.dialog.SolrArtifactChooserDialog', {
            artifactTypes: artifactType,
            autoShow: true,
            height: 400,
            title: title  + ' item(s)',
            multiple: true,

            storeConfig: {
                fetch:['UserStories','Name','FormattedID','TypePath','ObjectID','PortfolioItemType', 'PlannedStartDate','PlannedEndDate'],
                sorters: [
                    {
                        property: 'PortfolioItemType',
                        direction: 'DESC'
                    },
                    {
                        property: 'FormattedID',
                        direction: 'ASC'
                    }
                ]
            },

            listeners: {
                artifactchosen: function(dialogBox, selectedRecords) {

                    //Refresh the list of stuff we are looking at
                    var itmStr = "";
                    var objStr = [];

                    app.workItems = selectedRecords;

                    selectedRecords.forEach( function(record) {
                        delim = (itmStr === "")?"":" ";
                        itmStr += delim + record.get('FormattedID');
                        objStr.push(record.get('ObjectID'));
                    });


                    app.itmStr = itmStr;
                    app.objStr = objStr;

                    app.saveState();

                    //Fetch a new list of lowest level PIs for the items chosen
                    app._findAllLowestLevelPIs(app);


                }
            }
        });
    },

    _piBurnupChart: function(app) {

        if ( Ext.getCmp('piBurnupChart')){
            Ext.getCmp('piBurnupChart').destroy();
        }

        var objList = app.objStr;

        var piBurnupChart = Ext.create( 'Rally.ui.chart.Chart', {
            id: 'piBurnupChart',
            calculatorType: 'BurnupCalculator',
            calculatorConfig: {
                completedScheduleStateNames: ['Accepted', 'Released'],
                inProgressScheduleStateNames: ['In-Progress'],
                toDoScheduleStateNames: ['Triage', 'Defined' ]
            },
            storeConfig: {
                find: {
                    _TypeHierarchy: 'HierarchicalRequirement',
                    _ItemHierarchy: {$in:objList},
                    Children: null
                },
                fetch: ['ScheduleState', 'PlanEstimate'],
                hydrate: ['ScheduleState']
            },

            chartColors: [  Rally.util.Colors.logo_red,
                            Rally.util.Colors.lime_med,
                            Rally.util.Colors.blue_med,
                            Rally.util.Colors.grey6
                        ],

            chartConfig: {
                        chart: {
                            defaultSeriesType: 'area',
                            zoomType: 'xy'
                        },
                        title: {
                            text: 'PI Burnup'
                        },
                        xAxis: {
                            categories: [],
                            tickmarkPlacement: 'on',
                            tickInterval: 10,
                            title: {
                                text: 'Date',
                                margin: 10
                            }
                        },
                        yAxis: [
                            {
                                title: {
                                    text: 'Points'
                                },
                                min: 0
                            }
                        ],
                        tooltip: {
                            formatter: function() {
                                return '' + this.x + '<br />' + this.series.name + ': ' + this.y;
                            }
                        },
                        plotOptions: {
                            series: {
                                marker: {
                                    enabled: false,
                                    states: {
                                        hover: {
                                            enabled: true
                                        }
                                    }
                                },
                                groupPadding: 0.01
                            },
                            column: {
                                stacking: 'State',
                                shadow: false
                            }
                        }
                    }
        });
        Ext.getCmp('piBurnupBox').add(piBurnupChart);
        Ext.getCmp('piBurnupBox').setBorder(1);

    },

    _getFirstStartDate: function (app){
        var startDate = new Date();
        var itemLst = app.workItems;

        if (app.appConfig.useLowestPiDates === true )
        {
            itemLst = app.portfolioIds;
        }

        _.each(itemLst, function(item) {
            if (item.data.PlannedStartDate !== ""){
                if (Rally.util.DateTime.getDifference(startDate, new Date(item.data.PlannedStartDate), 'day' ) > 0) {
                    startDate = Ext.Date.parse(item.data.PlannedStartDate, 'c');
                }
            }
        });
        return startDate;
    },

    _getLastEndDate: function (app){
        var endDate = new Date();
        var itemLst = app.workItems;

        if (app.appConfig.useLowestPiDates === true )
        {
            itemLst = app.portfolioIds;
        }


        _.each(itemLst, function(item) {
            if (item.data.PlannedEndDate !== ""){
                if (Rally.util.DateTime.getDifference(endDate, new Date(item.data.PlannedEndDate), 'day' ) < 0) {
                    endDate = Ext.Date.parse(item.data.PlannedEndDate, 'c');
                }
            }
        });
        return endDate;
    },

    _piDefectList: function(app) {

        if ( Ext.getCmp('piDefectGrid')){
            Ext.getCmp('piDefectGrid').destroy();
        }


        var objList = app.objStr;

        var piStore = Ext.create('Rally.data.lookback.SnapshotStore', {
            autoLoad: true,
            storeId: 'piStore',
            fetch: ['FormattedID', 'Name', 'ScheduleState', 'PlanEstimate', 'State'],
            hydrate: ['FormattedID', 'Name', 'ScheduleState','PlanEstimate','State'],
            filters:  [ {
                            property: '_ItemHierarchy',
                            operator: '$in',
                            value: app.objStr
                        },
                        {
                            property: '_TypeHierarchy',
                            value: 'Defect'
                        },
                        {
                            property: "__At",
                            value: "current"    //Get only the latest version
                        },
                        {
                            property: 'State',
                            operator: '!=',
                            value: 'Closed'
                        }
            ],
            listeners: {
                load: function(store, data, success) {

                    _.each(data, function(record) {
                        record.set('_ref', '/defect/' + record.get('ObjectID'));
                        record.set('_type', 'defect');
                    });

                    var defectGrid = Ext.create('Rally.ui.grid.Grid', {
                        title: 'Active Defects connected to stories for selected items',
                        id: 'piDefectGrid',
                        enableColumnMove: true,
                        enableColumnResize: true,
                        columnCfgs: [
                            {
                                xtype: 'templatecolumn',
                                text: 'ID',
                                dataIndex: 'FormattedID',
                                tpl: Ext.create('Rally.ui.renderer.template.FormattedIDTemplate'),
                                width: 50
                            },
                            {
                                text: 'Name',
                                dataIndex: 'Name'
                            },
//                            {
//                                text: 'State',
//                                dataIndex: 'State'
//                            },
                            {
                                text: ' Schedule State',
                                dataIndex: 'ScheduleState',
                                renderer: function(value) {
                                    return value;
                                }
                            }
                        ],
                        sortableColumns: true,
                        store: store
                    });

                    Ext.getCmp('piDefectBox').add(defectGrid);
                    Ext.getCmp('piDefectBox').setBorder(1);
                    Ext.getCmp('piDefectBox').setMargin(10);

                    //Update the status banner
//                    app._defectStatusBanner(app, store);
                }
            }
        });

    },

    _defectStatusBanner: function (app, store) {

        var dispField = 'PlanEstimate';

        var defectPie = Ext.create('Ext.Container', {
            xtype: 'pie',
            id: 'piDefectStatusBox',
            animate: true,
            width: 100,
            height: 100,
            store: store,
            theme: 'Base:gradients',
            series: [{
                type: 'pie',
                angleField: dispField,
                showInLegend: true,
                tips: {
                    trackMouse: true,
                    width: 140,
                    height: 28,
                    renderer: function(storeItem, item) {
                        // calculate and display percentage on hover
                        var total = 0;
                        store.each(function(rec) {
                            total += rec.get(dispField);
                        });
                        this.setTitle(storeItem.get('FormattedID') + ': ' + storeItem.get(dispField));
                    }
                },
                highlight: {
                    segment: {
                        margin: 20
                    }
                },
                label: {
                    field: 'name',
                    display: 'rotate',
                    contrast: true,
                    font: '18px Arial'
                }
            }]
        });
        Ext.getCmp('piDefectStatusBox').add(defectPie);
        Ext.getCmp('piDefectStatusBox').show();

    },

    _piBurndownChart: function(app) {


        if ( Ext.getCmp('piBurndownChart')){
            Ext.getCmp('piBurndownChart').destroy();
        }

        var objList = app.objStr;

        //We need to get the end date for the original item - so that means no multiples
        if (app.itmStr.split(' ').length !== 1 ){
            Rally.ui.notify.Notifier.show( { message: 'Re-select a single item to get a meaningful Burndown Chart'});
        }

        var burndownchart = Ext.create( 'Rally.ui.chart.Chart', {
            id: 'piBurndownChart',
            storeType: 'Rally.data.lookback.SnapshotStore',
            storeConfig: {
                find: {
                    _TypeHierarchy: 'HierarchicalRequirement',
                    _ItemHierarchy: {$in:objList},
                    Children: null
                },

                fetch: ['ScheduleState', 'PlanEstimate', 'ObjectId', '_ValidFrom', '_ValidTo', 'To Do'],
                hydrate: ['ScheduleState'],
                sort: {
                    "_ValidFrom": 1
                },
                compress: true,
                useHttpPost: true
            },
            calculatorType: 'BurndownCalculator',
            calculatorConfig: {
                timeZone: "GMT",
                completedScheduleStateNames: ["Accepted", "Released"],
                enableProjections: true,
                //Uncomment to use counts of stories not velocity
//                chartAggregationType: 'storycount',
                startDate: app._getFirstStartDate(app),
                endDate: app._getLastEndDate(app)
            },

            chartColors: [  Rally.util.Colors.logo_red,
                            Rally.util.Colors.blue_med,
                            Rally.util.Colors.lime_med,
                            Rally.util.Colors.grey6
                        ],

            chartConfig: {
                chart: {
                    zoomType: "xy"
                },
                title: {
                    text: 'PI Burndown (Planned Estimate)'
                },
                xAxis: {
                    categories: [],
                    tickmarkPlacement: "on",
                    tickInterval: 14,
                    title: {
                        text: "Days",
                        margin: 12
                    },
                    maxPadding: 0.25,
                    labels: {
                        x: 0,
                        y: 20,
                        overflow: "justify"
                    }
                },
                yAxis: [
                    {
                        title: {
                            text: 'Points'
                        },
                        min: 0
                    }
                ],
                tooltip: {
                    formatter: function () {
                        var floatValue = parseFloat(this.y),
                            value = this.y;

                        if (!isNaN(floatValue)) {
                            value = Math.floor(floatValue * 100) / 100;
                        }

                        return "" + this.x + "<br />" + this.series.name + ": " + value;
                    }
                },
                plotOptions: {
                    series: {
                        marker: {
                            enabled: false,
                            states: {
                                hover: {
                                    enabled: true
                                }
                            }
                        },
                        connectNulls: true
                    },
                    column: {
                        pointPadding: 0,
                        borderWidth: 0,
                        stacking: null,
                        shadow: false
                    }
                }
            }
        });
        Ext.getCmp('piBurndownBox').add(burndownchart);
        Ext.getCmp('piBurndownBox').setBorder(1);
    },

    _piTreeList: function(app) {

        if ( Ext.getCmp('piHierarchy')){
            Ext.getCmp('piHierarchy').destroy();
        }

        // Create a sequence of OR 'ed filters
        var oredFilters = [];

        _.each(app.objStr, function (objID) {
            oredFilters.push({ property: 'ObjectID', value: objID});
        });

        var piType = 'portfolioitem/' + Ext.getCmp('typeSelector').rawValue;

        var tree = Ext.create('Rally.ui.tree.PortfolioTree',{
            id: 'piHierarchy',
            topLevelModel: piType,
            enableDragAndDrop: false,
            readOnly: true,
            topLevelStoreConfig: {
                filters: Rally.data.wsapi.Filter.or(oredFilters),
                fetch: ['FormattedID', 'Name', 'c_ProgressUpdate', 'PlannedStartDate', 'PlannedEndDate', 'PercentDoneByStoryCount','Children', 'ScheduleState', 'PlanEstimate','State']
            },
            emptyText: ' No items of type ' + piType + ' selected' //If we select the wront thing (using "ignore type") then we get nothing
        });
        Ext.getCmp('piTreeBox').add(tree);
        Ext.getCmp('piTreeBox').setBorder(1);
        Ext.getCmp('piTreeBox').setMargin(10);

    },

    _updateDetailsPanes: function(app){

        //Add the first chart after the header.
        app._piTreeList(app);
        app._piBurnupChart(app);
        app._piBurndownChart(app);
        app._piDefectList(app);

    },

    typeStore: null,

    launch: function() {

        var app = this;

        //The typeSelector will give us a store with the portfolio hierarchy in it.
        //We can work off the back of that

        var ignoreType = Ext.create( 'Rally.ui.CheckboxField', {
            fieldLabel: 'Ignore Type',
            id: 'ignoreType',
            value: app.appConfig.ignoreType,
            margin: 10,
            listeners: {
                change: function(newVal, OldVal, opts) {
                    app.appConfig.ignoreType = newVal.value;
                    app.saveState();
                }
            }
        });

        var useLowestPiDates = Ext.create( 'Rally.ui.CheckboxField', {
            fieldLabel: 'Use Plan Dates of lowest PI type',
            id: 'useLowestPiDates',
            value: app.appConfig.useLowestPiDates,
            margin: 10,
            listeners: {
                change: function(newVal, OldVal, opts) {
                    app.appConfig.useLowestPiDates = newVal.value;
                    app.saveState();
                    app._updateDetailsPanes(app);
                }
            }
        });


        var typeSelect = Ext.create( 'Rally.ui.combobox.PortfolioItemTypeComboBox', {
            id: 'typeSelector',
            margin: 10,
            listeners: {

                ready: function() {

                    app.typeStore = Ext.getCmp('typeSelector').store;

                    //Load the apps if we know what to do
                    if ( app.itmStr && app.objStr ) {
                        app._updateDetailsPanes(app);
                    }

                    //Add a button so that we can choose something of type in typeSelector
                    Ext.getCmp('headerBox').add( { xtype: 'rallybutton',
                        margin: 10,
                        id: 'doitButton',
                        text: 'Select Item(s)',
                        handler: function() {
                            app._doArtifactChooserDialog(app);
                        }
                    });

                    Ext.getCmp('headerBox').add(ignoreType);
                    Ext.getCmp('headerBox').add(useLowestPiDates);

                }
            }
        });

        Ext.getCmp('headerBox').insert(0, typeSelect);

    },

    getSettingsFields: function() {
        var me = this;
        return [
            {
                xtype: 'rallymodeltypepicker',
                fieldLabel: 'Parent type'
            }
        ];
    }
});


                Ext.define("DateMixin", {

    dateFormatters: [
        {key: "MMM", value: "%b"},
        {key: "MM", value: "%m"},
        {key: "dd", value: "%d"},
        {key: "yyyy", value: "%Y"}
    ],

    dateToStringDisplay: function (date) {
        return Ext.Date.format(date, 'm/d/Y');
    },

    dateToString: function (date) {
        return Ext.Date.format(date, 'Y-m-d\\TH:i:s.u\\Z');
    },

    dateStringToObject: function (dateStr) {
        var finalIndex = dateStr.indexOf('T'),
            dateObj;

        if (finalIndex > -1) {
            dateStr = dateStr.slice(0, dateStr.indexOf('T'));
        }

        dateObj = this._splitDateParts(dateStr);

        return new Date(dateObj.year, dateObj.month, dateObj.day);
    },

    _splitDateParts: function (dateStr) {
        if (this._shouldSplitOnDash(dateStr)) {
            return this._objectFromYearFirstDate(dateStr.split('-'));
        }
        else {
            return this._objectFromMonthFirstDate(dateStr.split('/'));
        }
    },

    _objectFromYearFirstDate: function (dateArray) {
        if (dateArray.length !== 3) {
            return { year: 0, month: 0, day: 0 };
        }

        dateArray[1] = (parseInt(dateArray[1], 10) - 1).toString();

        return {
            year: dateArray[0],
            month: dateArray[1],
            day: dateArray[2]
        };
    },

    _objectFromMonthFirstDate: function (dateArray) {
        if (dateArray.length !== 3) {
            return { year: 0, month: 0, day: 0 };
        }

        dateArray[0] = (parseInt(dateArray[0], 10) - 1).toString();

        return {
            month: dateArray[0],
            day: dateArray[1],
            year: dateArray[2]
        };
    },

    _shouldSplitOnDash: function (dateStr) {
        return dateStr.split('-').length === 3;
    }

});

                Ext.define('BurnupCalculator', {
                extend: 'Rally.data.lookback.calculator.TimeSeriesCalculator',
                config: {
                    completedScheduleStateNames: ['Accepted'],
                    inProgressScheduleStateNames: ['In Progress', 'Completed'],
                    toDoScheduleStateNames: ['Backlog', 'Defined' ]
                },
            
                constructor: function(config) {
                    this.initConfig(config);
                    this.callParent(arguments);
                },
            
                getDerivedFieldsOnInput: function() {
                    var completedScheduleStateNames = this.getCompletedScheduleStateNames();
                    var inProgressScheduleStateNames = this.config.inProgressScheduleStateNames;
                    var toDoScheduleStateNames = this.config.toDoScheduleStateNames;

                    return [
                        {
                            "as": "Planned",
                            "f": function(snapshot) {
                                if (snapshot.PlanEstimate) {
                                    return snapshot.PlanEstimate;
                                }
            
                                return 0;
                            }
                        },
                        {
                            "as": "PlannedCompleted",
                            "f": function(snapshot) {
                                if (_.contains(completedScheduleStateNames, snapshot.ScheduleState) && snapshot.PlanEstimate) {
                                    return snapshot.PlanEstimate;
                                }
            
                                return 0;
                            }
                        },
                        {
                            "as": "PlannedInProgress",
                            "f": function(snapshot) {
                                if (_.contains(inProgressScheduleStateNames, snapshot.ScheduleState) && snapshot.PlanEstimate) {
                                    return snapshot.PlanEstimate;
                                }
            
                                return 0;
                            }
                        },
                        {
                            "as": "PlannedToDo",
                            "f": function(snapshot) {
                                if (_.contains(toDoScheduleStateNames, snapshot.ScheduleState) && snapshot.PlanEstimate) {
                                    return snapshot.PlanEstimate;
                                }
            
                                return 0;
                            }
                        }
                    ];
                },
            
                getMetrics: function() {
                    return [

                        {
                            "field": "PlannedToDo",
                            "as": "To Do",
                            "f": "sum",
                            "display": "column"
                        },
                        {
                            "field": "PlannedInProgress",
                            "as": "In-progress",
                            "f": "sum",
                            "display": "column"
                        },
                        {
                            "field": "PlannedCompleted",
                            "as": "Accepted",
                            "f": "sum",
                            "display": "column"
                        },
                        {
                            "field": "Planned",
                            "as": "Planned",
                            "display": "line",
                            "f": "sum"
                        }
                    ];
                }
});


                Ext.define('BurndownCalculator', {
    extend: 'Rally.data.lookback.calculator.TimeSeriesCalculator',
    mixins: [
        'DateMixin'
    ],

    getDerivedFieldsOnInput: function () {
        var completedStates = this.config.completedScheduleStateNames,
            aggregationType = this.config.chartAggregationType;

        return [
            {
                "as": "RemainingPoints",
                "f": function (snapshot) {
                    var ss = snapshot.ScheduleState;
                    if(completedStates.indexOf(ss) < 0) {
                        if(aggregationType === "storycount") {
                            return 1;
                        } else if (snapshot.PlanEstimate) {
                            return snapshot.PlanEstimate;
                        }
                    }

                    return 0;
                }
            },
            {
                "as": "AcceptedPoints",
                "f": function (snapshot) {
                    var ss = snapshot.ScheduleState;
                    if (completedStates.indexOf(ss) > -1) {
                        if (aggregationType === "storycount") {
                            return 1;
                        } else if (snapshot.PlanEstimate) {
                            return snapshot.PlanEstimate;
                        }
                    }

                    return 0;
                }
            }
        ];
    },

    getMetrics: function () {
        return [
            {
                "field": "RemainingPoints",
                "as": "To Do",
                "f": "sum"
            },
            {
                "field": "AcceptedPoints",
                "as": "Accepted",
                "f": "sum"
            }
        ];
    },

    getSummaryMetricsConfig: function () {
        return [
            {
                'as': 'Scope_max',
                'f': function(seriesData) {
                        var max = 0, i = 0;
                        for (i=0;i<seriesData.length;i++) {
                            if(seriesData[i].Accepted + seriesData[i]['To Do'] > max) {
                                max = seriesData[i].Accepted + seriesData[i]['To Do'];
                            }
                        }
                        return max;
                     }
            }
        ];
    },

    getDerivedFieldsAfterSummary: function () {
        return  [
            {
                "as": "Ideal",
                "f": function (row, index, summaryMetrics, seriesData) {
                    var max = summaryMetrics.Scope_max,
                        increments = seriesData.length - 1,
                        incrementAmount;
                    if(increments === 0) {
                        return max;
                    }
                    incrementAmount = max / increments;
                    return Math.floor(100 * (max - index * incrementAmount)) / 100;
                },
                "display": "line"
            },
            {
                "as": "Prediction",
                "f": function (row, index, summaryMetrics, seriesData) {
                    return null;
                },
                "display": "line",
                "dashStyle": "Dash"
            }
        ];
    },

    getProjectionsConfig: function () {
        var days = (Rally.util.DateTime.fromIsoString(this.config.endDate).getTime() -
            Rally.util.DateTime.fromIsoString(this.config.startDate).getTime()) / (24*1000*60*60);
        var doubleTimeboxEnd = Ext.Date.add(Rally.util.DateTime.fromIsoString(this.config.startDate), Ext.Date.DAY, (Math.floor(days) * 2) - 1);
        var timeboxEnd = Ext.Date.add(Rally.util.DateTime.fromIsoString(this.config.endDate), Ext.Date.DAY, -1);
        if(this.projectionsConfig === undefined) {
            this.projectionsConfig = {
                doubleTimeboxEnd: doubleTimeboxEnd,
                timeboxEnd: timeboxEnd,

                series: [
                    {
                        "as": "Prediction",
                        "field": "To Do"
                    }
                ],
                continueWhile: function (point) {
                    var dt = Rally.util.DateTime.fromIsoString(point.tick);
                    var end = (this.series[0].slope >= 0) ? this.timeboxEnd : this.doubleTimeboxEnd;
                    return point.Prediction > 0 && dt < end;
                }
            };
        }
        return this.projectionsConfig;
    },

    _firstNonZero: function(data) {
         var i;
         for(i=0;i<data.length;i++) {
            if(data[i] > 0) {
                return i;
            }
         }
         return 0;
    },

    _leastSquares: function(todoValues, firstIndex, lastIndex) {
        var n = (lastIndex + 1) - firstIndex;
        var i;
        var sumx = 0.0, sumx2 = 0.0, sumy = 0.0, sumy2 = 0.0, sumxy = 0.0;
        var slope, yintercept;

        //Compute sums of x, x^2, y, y^2, and xy
        for (i = firstIndex; i <= lastIndex; i++) {
            sumx  = sumx  + i;
            sumx2 = sumx2 + i * i;
            sumy  = sumy  + todoValues[i];
            sumy2 = sumy2 + todoValues[i] * todoValues[i];
            sumxy = sumxy + i * todoValues[i];
        }
        slope = (n * sumxy - sumx * sumy) / (n * sumx2 - sumx * sumx);
        yintercept = (sumy * sumx2 - sumx * sumxy) / (n * sumx2 - sumx * sumx);

        return {slope: slope, yintercept: yintercept};
    },

    runCalculation: function (snapshots) {
        var chartData = this.callParent(arguments);

        if(chartData && chartData.projections) {
            var todoData = chartData.series[0].data;
            var firstTodoIndex = this._firstNonZero(todoData),
            lastTodoIndex = (todoData.length - 1) - chartData.projections.pointsAddedCount;

            var lastValidIndex = _.indexOf(todoData, 0) - 1;

            if (lastValidIndex <= 0) lastValidIndex = lastTodoIndex;

            var results = this._leastSquares(todoData, firstTodoIndex, lastValidIndex);

            // if the slope is positive, try using least squares.  If that's also positive, then use the first result
                // override the prediction line only if least squares says the slope isn't positive
                if(results.slope <= 0) {
                    this.projectionsConfig.series[0].slope = results.slope;

//                    chartData = this.callParent(arguments);

                    // project the plot back to the first todo value
                    var doingIndex = firstTodoIndex;
                    var doingVal = ((results.slope * doingIndex) + results.yintercept) - ((results.slope * lastValidIndex) + results.yintercept);

                    while  (doingIndex <= todoData.length) {
                        chartData.series[3].data[doingIndex] = doingVal;
                        doingIndex++;
                        doingVal = ((results.slope * doingIndex) + results.yintercept) - ((results.slope * lastValidIndex) + results.yintercept);
                    }

                    //Carry on until it hits zero or some time distant
//                    chartData.series[3].connectNulls = true;
                    this.projectionsConfig = undefined;
                } else {
                // DE18732, if the slope is up, truncate it at 1.25 of the max Ideal
                    var predictionCeiling = 1.25 * chartData.series[2].data[0];
                    if (_.max(chartData.series[3].data) > predictionCeiling) {
                        var i;
                        var maxVal = predictionCeiling;
                        for(i=0;i < chartData.series[3].data.length;i++) {
                            if(chartData.series[3].data[i] > predictionCeiling) {
                                chartData.series[3].data[i] = maxVal;
                                maxVal = null;
                            }
                        }
                    }
                }
        }

        if(new Date() < this.config.endDate) {
            this._recomputeIdeal(chartData, this.config.endDate);
        }

        return chartData;
    },

    _recomputeIdeal: function(chartData, endDate) {
         var index;
         if(chartData.categories.length < 1) {
            return;
         }
         if(this.workDays.length < 1) {
            return;
         }

         var lastDate = Ext.Date.parse(chartData.categories[chartData.categories.length - 1], 'Y-m-d');
         if(endDate > lastDate) {
            // the scopeEndDate date wasn't found in the current categories...we need to extend categories to include it
            // (honoring "workDays").

            index = chartData.categories.length;
            var dt = Ext.Date.add(lastDate, Ext.Date.DAY, 1);
            while (dt < endDate) {
                while (this.workDays.indexOf(Ext.Date.format(dt, 'l')) === -1) {
                    dt = Ext.Date.add(dt, Ext.Date.DAY, 1);
                }
                if (dt < endDate) {
                    chartData.categories[index++] = Ext.Date.format(dt, 'Y-m-d');
                }
                dt = Ext.Date.add(dt, Ext.Date.DAY, 1);
            }
            index = chartData.categories.length - 1;
         } else {
             // it is in "scope"...set index to the index of the last workday in scope
             index = this._indexOfDate(chartData, endDate);
             if(index === -1) {
                // it's in "scope", but falls on a non-workday...back up to the previous workday
                while (this.workDays.indexOf(Ext.Date.format(endDate, 'l')) === -1) {
                    endDate = Ext.Date.add(endDate, Ext.Date.DAY, -1);
                    index = this._indexOfDate(chartData, endDate);
                }
             }
         }
         if(index < 0) {
            return;
         }
         // set first and last point, and let connectNulls fill in the rest
         var i;
         var seriesData = chartData.series[2].data;
         for (i=1;i<index;i++) {
            seriesData[i] = null;
         }
         seriesData[index] = 0;
    },

    _indexOfDate: function(chartData, date) {
         var dateStr = Ext.Date.format(date, 'Y-m-d');
         return chartData.categories.indexOf(dateStr);
    },

    _removeFutureSeries: function (chartData, seriesIndex, dayIndex) {
        if(chartData.series[seriesIndex].data.length > dayIndex) {
            while(++dayIndex < chartData.series[seriesIndex].data.length) {
                chartData.series[seriesIndex].data[dayIndex] = null;
            }
        }
    },

    _projectionsSlopePositive: function (chartData) {
        if(chartData.projections && chartData.projections.series) {
            return chartData.projections.series[0].slope >= 0;
        }

        return true;
    }
});



            Rally.launchApp('Rally.app.WorkItemsForInitiative.app', {
                name:"WorkItemsForInitiative",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .app {
  /* Add app styles here */
}

    </style>
</head>
<body>
</body>
</html>
